38.HashCode和equals
equals：
Object类默认的实现是：return this == obj。即只有this和obj引用同一个对象，才会返回true。
而我们往往需要用equals来判断2个对象是否等价，而非验证他们的唯一性。这样在实现自己的类时，需要重写equals。
按约定，equals要满足以下规则。
[自反性]：x.equals(x)==true
[对null]：x.equals(null)==false
[对称性]：x.equals(y)==y.equals(x)
[传递性]：a.equals(b)==true && b.equals(c)==true => a.equals(c)==true

Hashcode：
此方法返回对象的散列码，返回值时int类型的散列码。对象的散列码是为了更好的支持基于哈希机制的Java集合类，如HashTable，HashMap等。
关于hashcode方法，一致的约定是：重写equals方法的对象必须同时重写hashCode()方法。
如果2个对象通过equals调用后返回true，那么这2个对象的hashCode方法也必须返回同样的int型散列码。
如果2个对象通过equals调用后返回true，那么这2个对象的hashCode方法返回值允许相同。
(然而，必须认识到，hashcode返回独一无二的散列码，会让存储这个对象的hashTable更好的工作)
(为保证以上约定，参与equals方法的字段，也必须都参加hashCode的计算)
hashcode一致约定要求：
【1】某个运行时期间，只要对象的(字段)变化不会影响equals方法的决策结果，那么，在这个期间，无论调用多少次hashcode，都必须返回同一个散列码。
【2】通过equals调用返回true的2个对象的hashcode一定一样。
【3】通过equals调用返回false的2个对象的散列码不需要不同(等价对象必须产生相同的散列码，不等价对象不要求产生的散列码不相同)

39.进程和线程的区别
【1】定义
进程是具有一定独立更能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源分配和调度的一个独立单位。
线程是进程的一个实体，是CPU调度和分派的基本单位，是比进程更小的能独立运行的基本单位。
线程自己基本上不拥有系统资源，只拥有一点在运行时必不可少的资源(如程序计数器，一组寄存器和栈)，但它可与同属一个进程的其他线程共享进程所拥有的全部资源。
【2】关系
一个线程可以创建和撤销另一个线程，同一个进程中的多个线程之间可以并发执行。
相对进程而言，线程是一个更加接近于执行体的概念，它可以与同进程中的其他线程共享数据，但拥有自己的栈空间，拥有独立的执行序列。
【3】区别
主要区别在于它们是不同的操作系统资源管理方式。
进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其他进程产生影响。
线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差。
此外，对于一些要求同时进行且要共享某些变量的并发操作，只能用线程。
	Ⅰ一个程序至少有一个进程，一个进程至少有一个线程。
	Ⅱ线程的划分尺度小于进程，使得多线程程序的并发性高。
	Ⅲ进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。
	Ⅳ每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。
	Ⅴ逻辑角度看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看作多个独立的应用，来实现进程的调度和管理以及资源分配，这就是进程和线程的重要区别。
【4】优缺点
线程执行开销小，但不利于资源的管理和保护，进程相反。

40.junit中before和beforeclass的区别
@before：在每个测试方法之前都会执行一次，只需声明成public。
@beforeclass：在类中只运行一次，必须声明成public static

41.触发器的作用是什么
比如说emp和dept两张表是有外键关联的，当emp存在相关数据时，dept无法删除数据，这时候就可以写个触发器，让他可以删除的同时对emp表的依赖数据发生变化。

42.当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递？
值传递。
Java只有值传递。当一个对象实例作为一个参数被传递到方法中，参数的值就是对该对象的引用。对象的内容可以在被调用的方法中改变，但对象的引用是永远不会改变的。
