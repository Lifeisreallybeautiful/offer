18.try{}里面有一个return语句，那么紧跟在这个try后面的finally{}里的code会不会被执行，什么时候被执行，在return前还是return后
会执行，在return后被执行。

19.final，finally，finalize的区别
final用户声明属性、方法和类，分别表示属性不可变，方法不可覆盖，类不可继承。
内部类要访问局部变量，局部变量必须定义为final类型。
finally是异常处理语句结构的一部分，表示总是执行。
finalize是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等。(JVM不保证此方法总被调用)。

20.运行时异常与一般异常有何异同
异常表示程序运行过程中可能出现的非正常状态。
运行时异常表示虚拟机的通常操作中可能遇到的异常，是一种常见运行错误。
Java编译器要求方法必须声明抛出可能发生的非运行时异常，但是不要求必须声明抛出未被捕获的运行时异常。

21.Java如何进行异常处理，throws，throw，try，catch，finally分别代表什么意义？在try中可以抛出异常吗
throws是获取异常；throw是抛出异常；try是将会发生的异常的语句括起来，进行异常的处理；catch是如果有异常就会执行它里面的语句；finally不论是否有异常都会执行语句。
throws和throw的详细区别：
throw是语法抛出一个异常。
语法：throw (异常对象)；throw e；
throws是方法可能抛出异常的声明。(用在声明方法时，表示该方法可能要抛出异常)
语法：(修饰符)(方法名)([参数列表])[throws(异常类)]{...}public void doA(int a) throws Exception1,Exception2{...}

22.Java中有几种方法可以实现一个线程？用什么关键字修饰同步方法
第一种：
new Thread(){}.start();表示调用Thread子类对象的run方法，new Thread(){}表示一个Thread的匿名子类的实例对象。
第二种：
new Thread(new Runnable(){}).start;表示调用Thread对象接受的Runnable对象的run方法，new Runnable(){}表示一个Runnable的匿名子类的实例对象。
第三种：
线程池创造。

用synchronized关键字修饰同步方法

23.sleep()和wait()有什么区别
sleep是线程类Thread的方法，导致此线程暂停执行指定时间，给执行机会给其他线程，但是监控状态依然保持，到时后会自动恢复。(调用sleep不会释放对象锁)
wait是Object类的方法对此对象调用wait方法导致本线程放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象发出的notify(notifyAll)方法后本线程才进入对象锁定池准备获得对象锁进入运行状态。

24.启动一个线程是用run()还是start()
启动一个线程是调用start()方法，使线程就绪状态，以后可以被调度为运行状态，一个线程必须关联一些具体的执行代码，run()方法是该线程所关联的执行代码。

25.List和Map的区别
List用于存储单列数据的集合，Map用于存储键值对的双列数据的集合。
List中存储的数据是有序的，且允许重复，Map中的数据是无序的，键不允许重复，值允许重复。

26.List，Set，Map是否继承自Collection接口
List、Set继承，Map未继承。

27.说说List、Set，Map的存储性能和特性
List和Set具有相似性，都是单列元素的集合，有一个共同的父接口，叫Collection。
Set里面不允许有重复的元素(不能加入两个相等的对象，add方法返回值为false)。Set取元素时，没法说取第几个，只能以Iterator接口取得所有的元素，再遍历各个元素。
List表示有先后顺序的集合。add(int index, Object e)方法可以指定插入的位置。一个对象可以反复存储进List中。
每调用一次add，在集合中用一个索引变量指向这个对象，当此对象被add多次时，相当于集合中有多个索引指向了这个对象。除了可以用Iterator接口取得所有的元素再逐一遍历，还可以调用get(index i)明确说明取第几个。
Map与前两者不同，是双列集合。put(Object key, Object value)不能存储重复的key，重复的规则也是按equals比较相等。

List以特定次序持有元素，可以有重复元素。Set不能有重复元素，内部排序。Map可以有重复的value，不能有重复的key。
(HashSet按照hashcode值的某种运算方式进行存储，而不是直接按照hashcode值的大小进行存储。
LinkedHashSet按插入的顺序存储，此时判断hashSet集合中两个对象是否相等，会先判断hashcode是否相等，再看equals是否相等。)

28.Set里的元素是不能重复的，那么用什么方法来区分重复呢？使用==还是equals？有何区别？
Set元素是否重复使用equals方法进行判断，为的是当两个分离的对象的内容和类型相配的时候，返回真值。

29.Java中有几种类型的流？JDK为每种类型的流提供了一些抽象类以供继承，请说出他们分别是哪些类
字节流和字符流。
字节流继承于InputStream和OutputStream，
字符流继承于InputStreamReader和OutputStreamWriter。

30.字节流和字符流的区别
字节流针对字节进行操作，主要用于二进制数据的输入输出，更面向于设备。
字符流针对字符进行操作，主要用于将二进制字节转换成字符，更面向于用户。
(字符流是字节流的包装；字符字节转换时，要注意编码问题)

31.什么是Java序列化？如何实现Java序列化？请解释Serializable接口的作用
①将一个Java对象转换成字节流的形式或者从一个字节流中恢复一个Java对象时，这个Java类必须实现serializable接口。
这样，javac编译时就会进行特殊处理，编译的类才可以被字节流方法操作，这就是所谓的序列化。
③实现序列化必须实现Serialiable接口，该接口是一个mini接口，其中没有要实现的方法，只是为了标注该对象是可被序列化的。
(web开发中，如果对象被存储到了Session中，tomcat再重启时要把Session对象序列化到硬盘，这个对象就必须实现Serializable接口)
(如果对象要经过分布式系统进行网络传输或者通过rmi等远程调用，这就需要在网络上传输对象，此时该对象必须实现Serializable接口)

32.能不能自己写个类，也叫java.lang.String？
可以，但在应用的时候，需要用自己的类加载器去加载。否则系统的类加载器永远只是去加载jre.jar包中的java.lang.String。
(tomcat的web应用中，都是由webapp自己的类加载器先自己加载web-INF/classess目录中的类，然后才委托上级的类加载器加载。
如果我们在tomcat的web应用程序中写一个java.lang.String，这时候Servlet加载的就是自己写的String，但是会有很多潜在问题)
(Java提供了endorsed技术，可以覆盖jdk中的某些类，但有限制范围，不包括java.lang下的类)

33.一个.java源文件中是否可以包括多个类(非内部类)？有什么限制？
可以有多个类，但只能有一个public的类(不包括静态类)，且public的类名必须与文件名一致。

34.JVM如何调优？
观察内存释放情况、集合类检查、对象数；查看堆空间大小分配(年轻代、年老代、持久代分配)
提供即使的垃圾回收功能；垃圾监控(长时间监控回收情况)
查看堆内类、对象的数量、类型等；对象引用情况查看
线程信息监控：查看系统线程的数量
线程状态监控：各个线程都处在什么样的状态下
Dump线程详细信息：查看线程内部运行状态
死锁检查

有了堆信息查看方面的功能，一般可以解决以下问题：
--年老代年轻代大小划分是否合理
--内存泄漏
--垃圾回收算法设置是否合理

内存泄漏检查：
内存泄漏是比较常见的问题，而且解决方案也比较通用。
内存泄漏一般可以理解为在错误使用的情况下，使用完毕的系统资源(各方面的资源、堆、栈、线程等)无法回收(或没有回收)，
从而导致新的资源分配请求无法完成，引起系统错误。
内存泄漏对系统危害较大，可以直接导致系统的崩溃。
解决：一般根据垃圾回收前后情况对比，同时根据对象引用情况(常见的集合对象引起)分析，基本都可以找到泄漏点。

持久代被占满：
异常：java.lang.OutOfMemoryError:PermGen space
Perm空间被占满。无法为新的class分配存储空间而引发的异常。主要原因是大量动态反射生成的类不断被加载，最终导致Perm区被占满。
需要注意的是不同的classLoader即使使用了相同的类，都会对其进行加载，因此某些情况下，此问题基本无解，当然，存在大量classLoader和大量反射类的情况也不多。
解决：1.-XX:MaxPermSize=16m 2.换用JDK，比如说JRocket

堆栈溢出：
异常：java.lang.StackOverflowError
一般是递归未返回，或者循环调用造成的。
解决：debug，瞪大眼睛瞅。

线程堆栈满：
异常：Fatal:Stack size too small
Java中一个线程的空间大小是有限制的，JDK5.0后是1M。此线程相关的数据会保存在其中。县城空间满后，将会出现上面异常。
解决：1.增加线程栈大小 -Xss2m 但这个配置无法解决根本问题，还要看代码部分受否有泄漏的地方。

系统内存被占满：
异常：java.lang.OutOfMemoryError:unable to create new native thread
由于操作系统没有足够的资源来产生这个线程造成的。
创建线程时，不止JVM中分配内存，操作系统本身也要分配资源，因此，分配给JVM的内存越多，系统总共能够产生的线程也就越少。
解决：1.重新设计系统减少线程数量 2.无法减少线程数量时，通过 -Xss 减小单个线程大小。

35.JVM如何加载类？如何分配空间？
将class文件的二进制数据读入到运行时数据区(JVM在内存中划分的)中，并在方法去内创建一个class对象。
JVM在运行起来时给内存划分空间，这块空间被称为运行时数据区。
运行时数据区被划分为一下几块内容：

【1】栈：
每一个线程运行起来时就会对应一个栈(线程栈)，栈中存放的线程是当前线程独享的(不会产生资源共享情况，所以线程是安全的)。
栈中存放的是栈帧，线程调用方法时，就是形成一个栈帧，并将这个栈帧进行压栈操作，方法执行完后进行出栈操作。
这个栈帧里包括局部变量、操作数栈、指向当前方法对应类的常量池引用、方法返回地址等信息。

【2】本地方法栈：
本地方法栈的机制和栈相似，区别在于，栈运行的是Java实现的方法，而本地方法栈运行的是本地方法(JVM需要调用非Java语言所实现的方法)

【3】程序计数器
也可以成为PC寄存器(通俗的讲就是指令缓存)，主要用于缓存当前程序下一条指令的指令地址，CPU根据这个地址找到将要执行的指令。
这个寄存器是JVM内部实现的，并不是物理概念上的计数器，不过和JVM的实现逻辑一样。

【4】堆
堆内存主要存放创建的对象和数组。堆内存在JVM中是唯一的，能被多个线程所共享。
堆里面的每一个对象都存放着类的实例变量。堆内存的对象没有被引用，会自动被Java垃圾回收机制回收。
当在方法中定义了局部变量，如果这个变量是基本数据类型，那么这个变量的值就直接存放在栈中；
如果是引用数据类型，那么变量值就存放在堆内存中，而栈中存放的是指向堆中的引用地址。

【5】方法区
和堆一样，可以被多个线程所共享。
主要存放每一个加载class的信息。
class信息主要包括魔数(确定是否是一个class文件)、常量池、
访问标志(当前的类是普通类还是接口，是否是抽象类，是否被public修饰，是否使用了final修饰等描述信息)、
字段表集合信息(使用什么访问修饰符，是实例变量还是静态变量，是否使用了final修饰等描述信息)、
方法表集合信息(使用什么访问修饰符，是否静态方法，是否使用了final修饰，是否使用了synchronized修饰，是否是native方法)等内容。
当一个类加载器加载了一个类的时候，会根据这个class文件创建一个class对象，class对象就包含了上述信息。
后续要创建这个类的实例，都根据这个class对象创建出来。

【6】常量池
是方法池中的一部分，存放class对象中最重要的资源。JVM为每一个class对象都维护一个常量池。

36.八个基本类型各占多少字节？
byte 1字节；char 2字节；
short 2字节；int 4字节；long 8字节；
float 4字节；double 8字节；
boolean 1字节；

37.HashMap、HashSet、HashTable的区别？
【1】继承的父类不同
HashTable继承自Dictionary类，而HashMap继承自AbstractMap类。但两者都实现了Map接口。
【2】线程安全性不同
HashTable中的方法是synchronized的，而HashMap中的方法在缺省情况下是非synchronized的。
【3】是否提供contains方法
HashMap把HashTable的contains方法去掉了，改成了containsValue和containsKey。
而HashTable则保留了contains方法和前两个方法，其中contains和containsvalue功能相同。
【4】key和value是否允许为null值
HashTable中key和value都不允许出现null。HashMap中，null可以作为key(只存在一个)，可以作为value(可以存在多个)。
当get()方法返回null值时，可能是HashMap中没有该key，也可能是其对应的value是null。
因此，HashMap中，判断某个key是否存在，应该用containsKey()方法进行判断。
【5】哈希值的计算方法不同
HashTable直接使用对象的hashcode，而HashMap则是在对象的hashCode基础上进行了一些变化。
【6】内部实现使用的数组初始化和扩容方式不同，内存初始大小不同。
HashTable初始大小是11，而HashMap初始大小是16。

