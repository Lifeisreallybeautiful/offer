1.事务四大特性(ACID)原子性、一致性、隔离性、持久性
原子性(Atomicity)：
原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚。因此事务的操作如果成功就必须完全应用到数据库，如果操作失败则不能对数据库有任何影响。
一致性(COnsistency)：
事务开始前和结束后，数据库的完整性约束没有被破坏。比如A向B转账，不可能A扣了钱，B却没收到。
隔离性(Isolation)：
当多个用户并发访问数据库时，比如说操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。
(涉及到数据库的隔离级别)
持久性(Durability)：
指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即使在数据库系统遇到故障的情况下也不会丢失提交事务的操作。

2.事务的并发？事务隔离级别，每个级别会引发什么问题，MySQL默认是哪个级别？
理论上来说，事务应该彼此完全隔离，以避免并发事务所导致的问题。然而，那样会对性能产生极大的影响，因为事务必须按顺序运行。
实际开发中，为了提升性能，事务会以较低的隔离级别运行，事务的隔离级别可以通过隔离事务属性指定。
【事务的并发问题】
Ⅰ脏读：事务A读取了事务B更新的数据，然后事务B回滚操作，那么A读取到的数据是脏数据。
Ⅱ不可重复读：事务A多次读取同一数据，事务B在事务A多次读取的过程中，对数据进行了更新并提交，导致事务A多次读取同一数据时，先后两次读到的数据结果会不一样。
Ⅲ幻读：事务T1对一个表中所有的行的某个数据项做了从1修改为2的操作，此时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为1，并且提交给了数据库。
	此时事务T1的用户如果再查看刚刚修改的数据，会发现还是跟没有修改一样，其实这行是从事务T2中添加的，就好像幻觉一样。
小结：不可重复读和幻读很容易弄混，不可重复读侧重于修改，幻读侧重于新增或删除，不可重复读的问题只需要锁住满足条件的行，解决幻读需要锁表。
【事务的隔离级别】
-----------------------------------------------------------------------------
-	事务隔离级别		-　　脏读	-　　不可重复读　　-      幻读	 -
-----------------------------------------------------------------------------
-读未提交 read-uncommitted    -    存在  -	   存在       -	   存在      -
-----------------------------------------------------------------------------
-不可重复读 read-committed 	 -   不存在  -      存在	  -	存在	 -
-----------------------------------------------------------------------------
-可重复读 repeatable-read     -   不存在  -      不存在	  -	存在	 -
-----------------------------------------------------------------------------
-串行化 serializable	   -   不存在  -	   不存在	   -	不存在	 -
-----------------------------------------------------------------------------

读未提交：另一个事务修改了数据，但尚未提交，而本事务中的SELECT会读到这些未被提交的数据脏读。
不可重复读：事务A多次读取同一数据，事务B在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，先后两次读到的数据结果会不一样。
可重复读：同一事务里，SELECT的结果是事务开始时间点的状态，因此，同样的SELECT操作读到的结果会是一致的，但是，会有幻读现象。
串行化：最高的隔离级别，在这个隔离级别下，不会产生任何异常。并发的事务，就像事务在一个个按顺序执行。

MySQL默认的事务隔离级别为repeatable-read。
MySQL中读未提交时，写数据只会锁住相应的属性。
不可重复读，会锁定正在读取的行。
可重复读，会锁定所读取的所有行。
串行化：会锁定整张表。

对于多数应用程序，可以优先考虑把数据库系统的隔离级别设为不可重复读，能够避免脏读，同时具有较好的并发性能。

3.MySQL常见的三种存储引擎(InnoDB、MyISAM、MEMORY)的区别？
【MyISAM与InnoDB】MySQL常用的两种引擎，大致区别在于：
·InnoDB支持事务，MyISAM不支持。这一点非常重要，事务是一种高级的处理方式，在增删改中出错可以回滚还原，而MyISAM不可以。
·MyISAM适合查询以及插入为主的应用，InnoDB适合频繁修改以及涉及到安全性较高的应用。
·InnoDB支持外键，MyISAM不支持。
·MySQL5.5.5后，InnoDB为默认引擎。
·InnoDB不支持FULLTEXT类型的索引。
·InnoDB中不保存表的行数，如SELECT COUNT(*) FROM TABLE 时，InnoDB需要扫描一遍表来计算有多少行，但MyISAM只要简单的读出保存好的行数即可。
(需要注意的是，当count(*)语句包含where条件时，MyISAM也需要扫描整个表)
·对于自增长的字段，InnoDB中必须包含只有该字段的索引，而MyISAM表中可以和其他字段一起建立联合索引。
·DELETE FROM TABLE时，InnoDB不会重新建立表，而是一行行的删除，效率非常慢。MyISAM则会重建表。
·InnoDB支持行锁(某些情况下还是锁整表，如UPDATE TABLE SET a=1 WHERE user LIKE '%zhang%')
【MyISAM与InnoDB的选择】
·InnoDB会支持一些二关系数据库的高级功能，如事务和行级锁，MyISAM不支持。
·MyISAM的性能更优，占用的存储空间少。
·如果应用程序一定要使用事务，毫无疑问选择InnoDB引擎。
·如果应用程序对查询性能要求较高，可以选择MyISAM。MyISAM索引和数据是分开的，而且其索引是压缩的，可以更好地利用内存。
(MyISAM拥有全文索引的功能，这可以极大优化LIKE查询的效率)

(现在一般都选用InnoDB了，主要是MyISAM的全表锁、读写串行问题，效率低)

【MEMORY存储引擎】
MEMORY是MySQL中一类特殊的存储引擎，它使用存储在内存中的内容来创建表，而且数据全部放在内存中。
每个基于MEMORY存储引擎的表实际对应一个磁盘文件，该文件的文件名和表名相同，类型为frm类型。
该文件只存储表的结构。而其数据文件都存储在内存中，有利于数据的快速处理，提高整个表的效率。
MEMORY默认使用哈希索引，速度比使用B型树索引快。
(MEMORY用到的很少，因为数据存到内存中，如果内存出现异常就会影响到数据，重启或者关机，数据都会消失。因此，基于MEMORY的表生命周期很短，一般是一次性的)。
